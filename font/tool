#!/usr/bin/env python3

import argparse
import json
import os
import sys
from pathlib import Path
from PIL import Image, ImageDraw

log_warning = log_notice = log_debug = print


class Grid:
    def __init__(self, lines, dots, dot_size, gap):
        self.lines = lines
        self.dots_x, self.dots_y = dots
        assert self.dots_y <= 8, 'Large fonts are not supported'
        self.dot_size = dot_size
        self.gap = gap

    def size(self):
        width = self.dot_size * self.dots_x + self.gap * 2
        height = (self.dot_size * self.dots_y * self.lines
                  + self.gap * (self.lines + 1))
        return width, height

    def dot_coord(self, line, dot_x, dot_y):
        x = self.gap + self.dot_size * dot_x
        y = (self.gap + self.dot_size * dot_y
             + line * (self.dot_size * self.dots_y + self.gap))
        return x, y


class Palette(dict):
    def __init__(self, bg, dot_0, dot_1):
       dict.__init__(self, {None: bg, 0: dot_0, 1: dot_1})

    def color_select(self, r, g, b):
        hex_color =  '#%02x%02x%02x' % (r, g, b)
        for index in self.keys():
            if self[index] == hex_color:
                return index
        raise ValueError('Wrong color')


class FontMetadata:
    def __init__(self, filename):
        filename = Path(filename).with_suffix('.json')
        log_notice('Reading metadata file', filename)
        with open(filename, 'r', encoding='utf-8') as file:
            self.data = json.load(file)
        self.lines = len(self.data['glyphs'])
        self.grid = Grid(self.lines, **self.data['grid'])
        self.pal = Palette(**self.data['color'])

    def new_img(self):
        self.img = Image.new('RGB', self.grid.size(), self.pal[None])
        self.draw = ImageDraw.Draw(self.img)

    def load_img(self):
        log_notice('Reading font image', self.data['image'])
        self.img = Image.open(self.data['image']).convert('RGB')

    def save_img(self):
        log_notice('Writing font image', self.data['image'])
        self.img.save(self.data['image'], 'PNG')

    def read_dot(self, line, dot_x, dot_y):
        x, y = self.grid.dot_coord(line, dot_x, dot_y)
        color = self.img.getpixel((x, y))
        return self.pal.color_select(*color[:3])

    def draw_dot(self, line, dot_x, dot_y, value):
        x2, y2 = x1, y1 = self.grid.dot_coord(line, dot_x, dot_y)
        x2 += self.grid.dot_size - 2
        y2 += self.grid.dot_size - 2
        self.draw.rectangle([x1, y1, x2, y2], fill=self.pal[value])


def load_font(font_file, required=False):
    try:
        with open(font_file, 'r', encoding='utf-8') as file:
            return json.load(file)
    except FileNotFoundError:
        log_warning('Font file', font_file, 'not found')
        if required:
            sys.exit('Cannot continue')
        return {}


def text2vlsb(font, text):
    out = b''
    for c in text:
        c = font.get('remap', {}).get(c, c);
        glyph = font.get(c, font.get('â–¯', ''))
        glyph = bytearray.fromhex(glyph)
        if out:
            left = out[-1]
            right = glyph[0]
            if left&right or (left>>1)&right or left&(right>>1):
                out += b'\x00' + glyph
            else:
                out += glyph
        else:
            out = glyph
    return out


def print_vlsb(vlsb, dots_y=8, print_fn=print):
    for y in range(dots_y):
        for c in vlsb:
            if c & 1<<y:
                print_fn('##', end='')
            else:
                print_fn('  ', end='')
        print_fn()


def cmd__read_font_from_images(font_file, metadata_files):
    font = {'remap': {}, ' ': '000000'}
    for metadata_file in metadata_files:
        fm = FontMetadata(metadata_file)
        font['remap'] |= fm.data.get('remap', {})
        fm.load_img()
        for line in range(fm.grid.lines):
            glyphs = fm.data['glyphs'][line]
            log_debug('Line', line, 'glyphs:', glyphs)
            dot_x = 0
            for glyph in glyphs:
                log_debug('Scanning glyph', glyph)
                glyph_bytes = ''
                glyph_end = False
                while not glyph_end:
                    glyph_byte = 0
                    for dot_y in range(fm.grid.dots_y):
                        dot_value = fm.read_dot(line, dot_x, dot_y)
                        if dot_value == None:
                            glyph_end = True
                        else:
                            glyph_byte |= dot_value << dot_y
                    dot_x += 1
                    if not glyph_end:
                        glyph_bytes += '%02x' % glyph_byte
                font[glyph] = glyph_bytes
                vlsb = bytearray.fromhex(glyph_bytes)
                print_vlsb(vlsb, fm.grid.dots_y, log_debug)
    log_notice('Writing font file', font_file)
    with open(font_file, 'w', encoding='utf-8') as file:
        json.dump(font, file, ensure_ascii=False, indent=4)
        file.write('\n')


def cmd__draw_font_image(font_file, metadata_file):
    font = load_font(font_file)
    fm = FontMetadata(metadata_file)
    fm.new_img()
    for line in range(fm.grid.lines):
        glyphs = fm.data['glyphs'][line]
        log_debug('Line', line, 'glyphs:', glyphs)
        dot_x = 0
        for glyph in glyphs:
            vlsb = bytearray.fromhex(font[glyph])
            for col in vlsb:
                for dot_y in range(fm.grid.dots_y):
                    value = int(bool(col & 1<<dot_y))
                    fm.draw_dot(line, dot_x, dot_y, value)
                dot_x += 1
            dot_x += 1
        for dot_x in range(dot_x, fm.grid.dots_x):
            for dot_y in range(fm.grid.dots_y):
                fm.draw_dot(line, dot_x, dot_y, 0)
                if line ==0 and dot_x == 0 and dot_y == 0:
                    fm.draw_dot(line, dot_x, dot_y, 1)
    fm.save_img()


def cmd__create_new_metadata_file(metadata_file):
    metadata_file = Path(metadata_file).with_suffix('.json')
    img_file = metadata_file.with_suffix('.png')
    meta = {
        'comment': 'Place your comments here',
        'image': str(img_file),
        'grid': {
            'dot_size': 8,
            'dots': [128, 8],
            'gap': 20
        },
        'color': {
            'bg': '#000000',
            'dot_0': '#3f3f3f',
            'dot_1': '#00ffff'
        },
        'glyphs': ['', '', '', ''],
        'remap': {}
    }
    log_notice('Creating new metadata file', metadata_file)
    with open(metadata_file, 'w', encoding='utf-8') as file:
        json.dump(meta, file, ensure_ascii=False, indent=4)
        file.write('\n')


def cmd__print_test_message(font_file, message):
    font = load_font(font_file, True)
    vlsb = text2vlsb(font, message)
    try:
        dots_y = (os.get_terminal_size().columns - 1) // 2
        while vlsb:
            print_vlsb(vlsb[:dots_y])
            vlsb = vlsb[dots_y:]
    except OSError:
        print_vlsb(vlsb)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-f', '--font', default='font.json',
        metavar='font.json', help='the font file to use')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-read', nargs='+', metavar='src',
        help='scan font image(s), save font to the font.json')
    group.add_argument('-write', metavar='meta[.json]',
        help='draw a font image file using the font.json')
    group.add_argument('-new', metavar='meta[.json]',
        help='create a new metadata file')
    group.add_argument('-test', metavar='message',
        help='print test message to stdout using the font.json')
    parser.add_argument('-v', '--verbose', action='store_true')
    args = parser.parse_args()
    if not args.verbose:
        log_debug = lambda *args, **kwarg: None
    if args.read:
        cmd__read_font_from_images(args.font, args.read)
    elif args.write:
        cmd__draw_font_image(args.font, args.write)
    elif args.new:
        cmd__create_new_metadata_file(args.new)
    else:
        cmd__print_test_message(args.font, args.test)
